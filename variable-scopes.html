<html>
    <head>
        <script>
var name = "Michael Jackson";

function showCelebrityName () {
    console.log (name);
}

function showOrdinaryPersonName () {    
    name = "Johnny Evers";
    console.log (name);
}
showCelebrityName (); // Michael Jackson

// name is not a local variable, it simply changes the global name variable
showOrdinaryPersonName (); // Johnny Evers

// The global variable is now Johnny Evers, not the celebrity name anymore
showCelebrityName (); // Johnny Evers

// The solution is to declare your local variable with the var keyword
function showOrdinaryPersonName () {    
    var name = "Johnny Evers"; // Now name is always a local variable and it will not overwrite the global variable
    console.log (name);
}

var name = "Paul";

function users () {
    // Here, the name variable is local and it takes precedence over the same name variable in the global scope
var name = "Jack";

// The search for name starts right here inside the function before it attempts to look outside the function in the global scope
console.log (name); 
}

users (); // Jack


function showAge () {
    // Age is a global variable because it was not declared with the var keyword inside this function
    age = 90;
    console.log(age);// 
}

showAge (); // 90

// Age is in the global context, so it is available here, too
console.log(age); // 90


// Both firstName variables are in the global scope, even though the second one is surrounded by a block {}. 
var firstName = "Richard";
{
var firstName = "Bob";
}

// To reiterate: JavaScript does not have block-level scope

// The second declaration of firstName simply re-declares and overwrites the first one
console.log (firstName); // Bob


for (var i = 1; i <= 10; i++) {
    console.log (i); 
};

// The variable i is a global variable and it is accessible in the following function with the last value it was assigned above 
function aNumber () {
console.log(i);
}

// The variable i in the aNumber function below is the global variable i that was changed in the for loop above. Its last value was 11, set just before the for loop exited:
aNumber ();  


 // The use of the "this" object inside the setTimeout function refers to the Window object, not to myObj

 var highValue = 200;
var constantVal = 2;
var myObj = {
    highValue: 20,
    constantVal: 5,
    calculateIt: function () {
 setTimeout (function  () {
    console.log(this.constantVal * this.highValue);
}, 2000);
    }
}

// The "this" object in the setTimeout function used the global highValue and constantVal variables, because the reference to "this" in the setTimeout function refers to the global window object, not to the myObj object as we might expect.

myObj.calculateIt(); // 400
// This is an important point to remember.

var firstName="Mahith", lastName="Rao";

function fullName1 () {
    console.log ("Full Name: " + firstName + " " + lastName );
}

fullName1();


function fullName () {
    var firstName = "Michael", lastName = "Jackson";

    console.log ("Full Name: " + firstName + " " + lastName );
}
fullName();


function showName1 () {
console.log ("First Name: " + name);
var name = "Ford";
console.log ("Last Name: " + name);
}

showName1 (); 

showName();

function showName () {
    var name;
console.log ("First Name: " + name); // First Name: undefined

name = "polo"; // name is assigned a value

// now name is Ford
console.log ("Last Name: " + name); // Last Name: Ford
}

 // Both the variable and the function are named myName
 var myName;
function myName () {
console.log ("Rich");
}

// The function declaration overrides the variable name
console.log(typeof myName); // function


 // But in this example, the variable assignment overrides the function declaration
 var myName1 = "Richard"; // This is the variable assignment (initialization) that overrides the function declaration.

function myName1 () {
console.log ("Rich");
}

console.log(typeof myName1); // string 
        </script>
    </head>
    <body>
        
    </body>
</html>